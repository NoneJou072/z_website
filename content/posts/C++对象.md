# 1.类
在了解类之前，我们需要首先了解一下什么是面向对象。
## 1.1面向对象的三大特征
（来源于百度百科）
 - **封装性**：封装使数据和加工该数据的方法（函数）封装为一个整体，以实现独立性很强的模块，使得用户只能见到对象的外特性（对象能接受哪些消息，具有那些处理能力），而对象的内特性（保存内部状态的私有数据和实现加工能力的算法）对用户是隐蔽的。封装的目的在于把对象的设计者和对象者的使用分开，使用者不必知晓行为实现的细节，只须用设计者提供的消息来访问该对象。
 - **继承性**：继承性是子类自动共享父类之间数据和方法的机制。它由类的派生功能体现。一个类直接继承其它类的全部描述，同时可修改和扩充。继承具有传递性。继承分为单继承(一个子类只有一父类)和多重继承(一个类有多个父类)。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。
 - **多态性**：所谓多态就是指对象根据所接收的消息而做出动作，同一消息为不同的对象接受时可产生完全不同的行动，这种现象称为多态性。多态机制使具有不同内部结构的对象可以共享相同的外部接口。

## 1.2类的访问权限
在C++中，我们使用**访问说明符**加强类的封装性，一个类可以包含0个或多个访问说明符。

 - 定义在**public**说明符之后的成员在**整个程序**内可被访问，public成员定义类的接口。
 - 定义在**private**说明符之后的成员可以被**该类的中的函数**以及**友元函数**访问，但是不能被使用该类的代码访问，private部分封装了类的实现细节。
 - 定义在**protected**说明符之后的成员可以被**该类中的函数**、**子类的函数**、以及其**友元函数**访问,但不能被该类的对象访问。
# 2.vector
标准库类型vector（**容器**）表示对象的集合，其中需要所有的对象类型都相同。集合中的每个对象都有一个与之对应的索引，用于访问对象。
vector是一个**类模板**，编译器根据模板创建类或函数的过程为**实例化**，使用模板时，需要指出编译器应把类或函数实例化成何种类型，即在**模板名字后跟一对尖括号**，在括号中放上信息。

则`vector<int> preorderTraversal`表示，在pre中保存int类型的对象。
## 2.1定义和初始化vector对象
|方法| 含义 |
|--|--|
| vector\<T> v1 | v1是一个空容器，类型为T |
| vector\<T> v2(v1)| v2中包含有v1所有元素的副本 |
| vector\<T> v2 = v1 | 等价于v2(v1) |
| vector\<T> v3(n, val) | v3包含了n个val |
| vector\<T> v4(n) | v4包含了n个初始化T的对象 |
| vector\<T> v5{a, b, c...} | v5包含了初始个数的元素，每个元素被赋予相应的值 |
| vector\<T> v5 = {a, b, c...} | 等价于v5{a, b, c...}  |
## 2.2向vector对象中添加元素
vector的成员函数**push_back**能够把一个值当成vector对象的尾元素push到vector对象的尾端。
例如`ret.push_back(root->val);`
注：如果在循环体内部包含有向vector对象添加元素的语句，不能使用范围for循环。
## 2.3其它vector操作
|操作| 含义 |
|--|--|
| v.empty() | 如果v中不含有任何元素，返回真，否则返回假 |
| v.size() | 返回v中元素的个数 |
| v.push_back(t) | 向v的尾端添加一个值为t的元素 |
|v[n]|返回v中第n个位置上元素的引用|
|v1 = v2|用v2中元素的拷贝替换v1中的元素|
|v1 = {a, b, c...}|用列表中元素的拷贝替换v1中的元素|
|v1 == v2|判断v1和v2中的元素数量与对应元素值都相等|
|v1 != v2||
|<, <=, >, >=|以字典顺序进行比较|

注：不能用下标形式添加元素。
# 3.nullptr
在c语言中，NULL实际上是一个空指针，在使用中被隐式转换成其它类型；
而c++是强类型语言，不能进行隐式类型转换，NULL直接定义为0，定义nullptr为空指针。

